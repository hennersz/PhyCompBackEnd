# PhyCompBackEnd

##Installation
Requires node and npm to be installed

To install the node dependancies run.
```
npm install
npm install -g nodemon
```

then start the app with `npm start` or `npm debug` to run with debugging messages

This will need a mongo database running as described below.

##Database
We use [MongoDB](https://www.mongodb.org) for the database. When running the app as development or test you will need to have a database running locally. Once you have mongo installed run it with `mongod`. If you wish to use a database that isn't running on the default port or isn't running locally change the URI in \_config which is described below.

##_config.js
This config file is used to specify the database URIs for development, testing and production. It will look something like this: 
``` javascript
var config = {};

config.mongoURI = {
  development: 'localhost:27017/pollution',
  test: 'localhost:27017/test-data',
  production: process.env.DBUSER + ':' + process.env.DBPASS + '@ds055945.mlab.com:55945/pollution'
};

module.exports = config;
```
In our example we store the credentials for the production database as environment variables on the machine the app is running on.

it is then called in app.js in a similar way to here:
``` javascript
var config = require('./_config');
var monk = require('monk');
var db = monk(config.mongoURI[app.get('env')]);
```


##API docs
To generate the API docs first you have to install [apidocsjs](http://apidocjs.com)

`npm install -g apidoc`

Then run `apidoc -i routes/ -o public/Docs` to generate the files needed. This takes routes as the input directory and public/Docs as the output directory. 

##Testing
Unit testing is done using [Mochajs](http://mochajs.org) which you can install with `npm install -g mocha`
We also make use of [chaijs](http://chaijs.com) and the chaihttp plugin but these will be installed as dependencies.

To run the tests use `mocha`
Mocha will run all files in the test directory.



##App Structure
```
.
├── Procfile //Specifies startup script for running the app like a heroku app only locally
├── README.md
├── _config.js
├── app
│   └── schema.js
├── app.js
├── bin
│   └── www // sets up express app to listen on a port with some error handling code
├── node_modules
├── package.json
├── public
│   ├── Docs
│   ├── images
│   ├── javascripts
│   │   └── maps.js
│   └── stylesheets
│       └── style.css
├── routes
│   ├── api.js
│   └── index.js
├── test
│   └── test-server.js
└── views
    ├── error.jade
    ├── index.jade
    ├── layout.jade
    └── map.jade

```
The main file for the app is app.js this is where most other files ultimately connect into. The middleware for handling requests and dealing with errors is defined here as well as the periodic connection to the external APIs. 

The public directory contains all the static files that are needed. This is not really used much apart from a couple of files and the Docs directory where all the files generated by apidocs.js are stored

The routes Directory contains all the express routing code.

Views containes all the [jade](http://jade-lang.com) files for the views. Each view inherits from layout.jade which contains some features that are common to all other views.

##Schema
All the data we get from the various sources has to be converted to a single format so all data recieved from the API is consistent. The schema is in this form: 
``` javascript
{
  "datetime":"2015-07-15T10:52:14Z",
  "data":{
    "no2":{"value":1,"units":"AirQualityIndex","raw_value":0.27176,"raw_units":"ppm"},
    "co":{"value":1,"units":"AirQualityIndex","raw_value":6.1601333333333335,"raw_units":"ppm"},
    "light":{"value":49.8,"units":"Lux","raw_value":49.8,"raw_units":"Lux"},
    "noise":{"value":50,"units":"dB","raw_value":50,"raw_units":"dB"},
    "so2":null,
    "o3":null,
    "pm10":null,
    "pm25":null
  },
  latitude:51.5073509,
  longitude:-0.127758299999982
}

```
Some important features to note when adding new data sources into the schema is that the data object must have entries for all polluton types even if the data source doesnt provide that kind of pollution. Instead add it as a null value. We also convert the raw value for polluton into a 1 to 10 scale. `normaliseValue(data)` in schema.js can do the conversion for the pollution types we currently support but you will have to add in your own calculations for other pollutuion types. 
The `schema()` function in schema.js is the interface between the data recieved from the API and our schema. To add a new data set to the API you will have to write your own function that can convert a record into our schemas format then call it inside `schema()` on each record from the data set. You also need to pass the data set as an extra argument to `schema()` which is called in app.js
